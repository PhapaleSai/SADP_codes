//slip 5:-
//Give File name :- AdapterDemo.java
//Write a Java Program to implement Adapter pattern for Enumeration and iterator ->

import java.util.Enumeration;
import java.util.Iterator;
import java.util.Vector;

class EnumerationIteratorAdapter<T> implements Iterator<T>
 {
    private final Enumeration<T> enumeration;

    public EnumerationIteratorAdapter(Enumeration<T> enumeration)
    {
        this.enumeration = enumeration;
    }

    public boolean hasNext() { return enumeration.hasMoreElements(); }
    public T next() { return enumeration.nextElement(); }
    public void remove() 
    { throw new UnsupportedOperationException("Remove not supported"); 
    }
}

public class AdapterDemo {
    public static void main(String[] args)
     {
        Vector<String> vector = new Vector<>();
        vector.add("Apple");
        vector.add("Banana");
        vector.add("Cherry");

        Iterator<String> iterator = new EnumerationIteratorAdapter<>(vector.elements());
        iterator.forEachRemaining(System.out::println);
    }
}

/* Output:
// Apple
// Banana
// Cherry

Adapter pattern Explanation:
**ðŸ”¹ Pattern Type:**
Structural Design Pattern

**ðŸ”¹ Definition:**
Allows incompatible interfaces to work together by wrapping one class with an adapter that converts its interface into one expected by the client.

**ðŸ”¹ Why to Use:**
Used when you want to integrate classes with mismatched interfaces without modifying their code.

**ðŸ”¹ Real-life Example:**
Like a power adapter â€” lets a European plug fit into an Indian socket.
Or a card reader â€” lets an SD card connect via a USB port.

**ðŸ”¹ Advantages:**

* Increases code reusability and compatibility.
* Allows integration of legacy code with new systems.

**ðŸ”¹ Disadvantages:**

* Adds an extra layer of complexity.
* Can make debugging harder due to multiple levels of abstraction.
*/
