// slip 12:-
//Give FileName:- CarDecoratorDemo.java
// Write a Java Program to implement Decorator Pattern for interface Car to define the assemble() method and then decorate it to Sports car and Luxury Car

// Car interface
interface Car {
    String assemble();
}

// Basic Car implementation
class BasicCar implements Car {
    public String assemble() 
    {
         return "Basic Car";
    }
}

// Decorators
class SportsCar implements Car {
    private Car car;
    SportsCar(Car car) { this.car = car; }
    public String assemble() { return car.assemble() + " + Sports Package"; }
}

class LuxuryCar implements Car {
    private Car car;
    LuxuryCar(Car car) { this.car = car; }
    public String assemble() { return car.assemble() + " + Luxury Package"; }
}

// Client
public class CarDecoratorDemo {
    public static void main(String[] args) {
        Car basicCar = new BasicCar();
        System.out.println(basicCar.assemble());

        Car sportsCar = new SportsCar(basicCar);
        System.out.println(sportsCar.assemble());

        Car luxurySportsCar = new LuxuryCar(sportsCar);
        System.out.println(luxurySportsCar.assemble());
    }
}

/* Output:
// Basic Car
// Basic Car + Sports Package
// Basic Car + Sports Package + Luxury Package

/*Explanation:-

### ðŸŽ“ **Decorator Pattern (Summary)**

**Type:**
**Structural Design Pattern**

**Definition:**
A **structural design pattern** that lets you **add new behavior to objects dynamically** without changing their original class. It wraps an object with another (decorator) that adds or modifies functionality.

**Intent:**

* Extend or modify object behavior **at runtime**.
* Avoids subclassing for every new feature.

**Real-Life Example:**
In a **coffee shop**, you start with plain coffee and add milk or sugar â€” each decorator adds new features.

**Advantages:**
âœ” Adds behavior dynamically
âœ” Promotes flexibility and code reuse
âœ” Avoids many subclasses

**Disadvantages:**
âœ– Can create many small classes
âœ– Debugging becomes harder
âœ– Structure may get complex if overused

*/

