// Slip 17
//Give File Name as :- AbstractFactoryDemo.java
// Slip 17
// Write a Java Program to implement Abstract Factory Pattern for Shape interface. 

interface Shape { void draw(); }

class Circle implements Shape { public void draw(){System.out.println("Drawing Circle");} }
class Square implements Shape { public void draw(){System.out.println("Drawing Square");} }
class Rectangle implements Shape { public void draw(){System.out.println("Drawing Rectangle");} }

interface AbstractFactory { Shape createShape(String type); }

class ShapeFactory implements AbstractFactory
 {
    public Shape createShape(String type){
        return switch(type.toUpperCase()){
            case "CIRCLE" -> new Circle();
            case "SQUARE" -> new Square();
            case "RECTANGLE" -> new Rectangle();
            default -> null;
        };
    }
}

class FactoryProducer {
     static AbstractFactory getFactory()
     { 
        return new ShapeFactory(); 
    } 
     }

public class AbstractFactoryDemo {
    public static void main(String[] args){
        AbstractFactory f = FactoryProducer.getFactory();
        f.createShape("CIRCLE").draw();
        f.createShape("SQUARE").draw();
        f.createShape("RECTANGLE").draw();
    }
}

/* Output:-
// Drawing a Circle
// Drawing a Square
// Drawing a Rectangle

**ğŸ”¹ Pattern Type:**
Creational Design Pattern

**ğŸ”¹ Definition:**
Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

**ğŸ”¹ Why to Use:**
Used when a system needs to create multiple related objects that must work together, but you want to keep creation logic independent of the main code.

**ğŸ”¹ Real-life Example:**
Like a furniture company â€” one factory makes â€œModernâ€ style (modern chair, modern table), another makes â€œVictorianâ€ style furniture.
The client just asks for a factory type, not specific items.

Imagine you have two factories:
CarFactory â†’ creates Car and CarEngine
BikeFactory â†’ creates Bike and BikeEngine

The client just says:
â€œGive me a factory for Cars or Bikes.â€
Then it uses that factory to create the matching parts â€” without knowing how theyâ€™re built.

**ğŸ”¹ Advantages:**

* Ensures consistency among related products.
* Makes it easy to switch product families or add new ones.

**ğŸ”¹ Disadvantages:**
* Adds complexity with many interfaces and classes.
* Difficult to support new product types without changing existing code.

*/


// Output:-
// Drawing a Circle
// Drawing a Square
// Drawing a Rectangle

