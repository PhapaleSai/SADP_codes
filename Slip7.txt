//slip 7
//Give FileName:- CeilingFanDemo.java
//Write a Java Program to implement undo command to test Ceiling fan. 

// Command interface
interface Command {
    void execute();
    void undo();
}

// Receiver
class CeilingFan {
    void high() { System.out.println("Ceiling Fan is HIGH"); }
    void off()  { System.out.println("Ceiling Fan is OFF"); }
}

// Concrete Command
class FanHighCommand implements Command {
    private CeilingFan fan;
    FanHighCommand(CeilingFan fan) { this.fan = fan; }

    public void execute() { fan.high(); }
    public void undo()    { fan.off(); }
}

// Invoker
class RemoteControl {
    private Command command;
    void setCommand(Command c) { command = c; }
    void pressButton() { command.execute(); }
    void pressUndo()   { command.undo(); }
}

// Client
public class CeilingFanDemo {
    public static void main(String[] args) 
    {
        CeilingFan fan = new CeilingFan();
        RemoteControl remote = new RemoteControl();

        remote.setCommand(new FanHighCommand(fan));
        remote.pressButton();  // Fan HIGH
        remote.pressUndo();    // Fan OFF
    }
}

// Output:
// Ceiling Fan is HIGH
// Ceiling Fan is OFF


/*Explanation:-Command Pattern
**ðŸ”¹ Pattern Type:**
Behavioral Design Pattern

**ðŸ”¹ Definition:**
Encapsulates a request as an object, allowing you to parameterize clients with queues, requests, and operations.

**ðŸ”¹ Why to Use:**
Used to decouple the object that issues a request from the one that performs it â€” helps with undo/redo, logging, and task scheduling.

**ðŸ”¹ Real-life Example:**
Like a TV remote â€” each button (command) tells the TV (receiver) what to do (turn on/off, change channel).
You can press, undo, or redo commands easily.

**ðŸ”¹ Advantages:**

* Decouples sender and receiver.
* Supports undo/redo and command history easily.

**ðŸ”¹ Disadvantages:**

* Increases number of classes.
* Can add complexity for simple actions.
*/


