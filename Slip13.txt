// Slip 13
Give FileName :- MobileChargerAdapterDemo.java
// Write a Java Program to implement an Adapter design pattern in mobile charger. 
// Define two classes â€“ Volt (to measure volts) and Socket (producing constant volts of 
// 120V). Build an adapter that can produce 3 volts, 12 volts and default 120 volts. 
// Implements Adapter pattern using Class Adapter

// Volt
class Volt {
    private int volts;
    Volt(int v) { volts = v; }
    int getVolts() { return volts; }
}

// Adaptee
class Socket {
    Volt getVolt() { return new Volt(120); }
}

// Target
interface SocketAdapter {
    Volt get3Volt();
    Volt get12Volt();
    Volt get120Volt();
}

// Class Adapter
class SocketClassAdapter extends Socket implements SocketAdapter {
    public Volt get3Volt() { return new Volt(getVolt().getVolts()/40); }
    public Volt get12Volt() { return new Volt(getVolt().getVolts()/10); }
    public Volt get120Volt() { return getVolt(); }
}

// Client
public class MobileChargerAdapterDemo {
    public static void main(String[] args) {
        SocketAdapter ad = new SocketClassAdapter();
        System.out.println("3V: " + ad.get3Volt().getVolts());
        System.out.println("12V: " + ad.get12Volt().getVolts());
        System.out.println("120V: " + ad.get120Volt().getVolts());
    }
}

// Output:
// 3V: 3
// 12V: 12
// 120V: 120

/* Adapter pattern Explanation:
Adapter pattern Explanation:
**ðŸ”¹ Pattern Type:**
Structural Design Pattern

**ðŸ”¹ Definition:**
Allows incompatible interfaces to work together by wrapping one class with an adapter that converts its interface into one expected by the client.

**ðŸ”¹ Why to Use:**
Used when you want to integrate classes with mismatched interfaces without modifying their code.

**ðŸ”¹ Real-life Example:**
Like a power adapter â€” lets a European plug fit into an Indian socket.
Or a card reader â€” lets an SD card connect via a USB port.

**ðŸ”¹ Advantages:**

* Increases code reusability and compatibility.
* Allows integration of legacy code with new systems.

**ðŸ”¹ Disadvantages:**

* Adds an extra layer of complexity.
* Can make debugging harder due to multiple levels of abstraction.
*/  

