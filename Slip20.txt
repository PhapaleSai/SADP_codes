//SLIP 1 and Slip 20
Give fileName :- DecoratorExample.java
//  - Q.1 Write a Java Program to implement I/O Decorator for converting uppercase letters to lower case letters.(Decorator Pattern Example in Java)

class TextMessage {
    private String text;

    public TextMessage(String text) 
    {
        this.text = text;
    }

    public String getText() 
    {
        return text;
    }

    // Decorator method to convert text to lowercase
    public TextMessage toLowerCase() 
    {
        this.text = this.text.toLowerCase();
        return this;  // return the same object for chaining
    }
}

// Main class
public class DecoratorExample {
    public static void main(String[] args) 
    {
        TextMessage message = new TextMessage("Hello, WORLD!");
        message.toLowerCase();  // Apply the lowercase transformation
        System.out.println(message.getText());  
    }
}

// Output: hello, world!

/*Explanation:-

### ðŸŽ“ **Decorator Pattern (Summary)**

**Definition:**
A **structural design pattern** that lets you **add new behavior to objects dynamically** without changing their original class. It wraps an object with another (decorator) that adds or modifies functionality.

**Intent:**

* Extend or modify object behavior **at runtime**.
* Avoids subclassing for every new feature.

**Real-Life Example:**
In a **coffee shop**, you start with plain coffee and add milk or sugar â€” each decorator adds new features.

**Advantages:**
âœ” Adds behavior dynamically
âœ” Promotes flexibility and code reuse
âœ” Avoids many subclasses

**Disadvantages:**
âœ– Can create many small classes
âœ– Debugging becomes harder
âœ– Structure may get complex if overused

**Type:**
**Structural Design Pattern**

---
*/
