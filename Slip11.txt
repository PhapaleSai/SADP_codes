//slip 11 
//Give FileName:- HeartAdapterDemo.java
// Write a java program to implement Adapter pattern to design Heart Model to Beat Model

// Adaptee
class HeartModel {
    void beat() { System.out.println("Heart is beating..."); }
}

// Target interface
interface BeatModel {
    void start();
    void stop();
    void setBPM(int bpm);
}

// Adapter
class HeartAdapter implements BeatModel {
    private HeartModel heart;
    HeartAdapter(HeartModel heart) { this.heart = heart; }

    public void start() { heart.beat(); }
    public void stop() { System.out.println("Heart beat stopped."); }
    public void setBPM(int bpm) { System.out.println("Setting BPM: " + bpm); }
}

// Client
public class HeartAdapterDemo {
    public static void main(String[] args) {
        BeatModel beatAdapter = new HeartAdapter(new HeartModel());

        beatAdapter.start();
        beatAdapter.setBPM(72);
        beatAdapter.stop();
    }
}

/* Output:
// Heart is beating...
// Setting BPM: 72
// Heart beat stopped.

Adapter pattern Explanation:
**ðŸ”¹ Pattern Type:**
Structural Design Pattern

**ðŸ”¹ Definition:**
Allows incompatible interfaces to work together by wrapping one class with an adapter that converts its interface into one expected by the client.

**ðŸ”¹ Why to Use:**
Used when you want to integrate classes with mismatched interfaces without modifying their code.

**ðŸ”¹ Real-life Example:**
Like a power adapter â€” lets a European plug fit into an Indian socket.
Or a card reader â€” lets an SD card connect via a USB port.

**ðŸ”¹ Advantages:**

* Increases code reusability and compatibility.
* Allows integration of legacy code with new systems.

**ðŸ”¹ Disadvantages:**

* Adds an extra layer of complexity.
* Can make debugging harder due to multiple levels of abstraction.*/

