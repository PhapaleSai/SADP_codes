//Slip 10:-
//Give FileName:- DuckStrategyDemo.java(Slip 10)
// Write a Java Program to implement Strategy Pattern for Duck Behavior. Create instance variable that holds current state of Duck from there, we just need to handle all Flying Behaviors and Quack Behavior

// Strategy Interfaces
interface FlyBehavior { void fly(); }
interface QuackBehavior { void quack(); }

// Concrete Behaviors
class FlyWithWings implements FlyBehavior { public void fly() { System.out.println("Flying with wings!"); } }
class FlyNoWay implements FlyBehavior { public void fly() { System.out.println("I can't fly."); } }
class Quack implements QuackBehavior { public void quack() { System.out.println("Quack! Quack!"); } }
class MuteQuack implements QuackBehavior { public void quack() { System.out.println("... (Silence)"); } }

// Duck Class
abstract class Duck {
    FlyBehavior flyBehavior;
    QuackBehavior quackBehavior;

    void performFly() { flyBehavior.fly(); }
    void performQuack() { quackBehavior.quack(); }
    void swim() { System.out.println("All ducks can swim!"); }
    void setFlyBehavior(FlyBehavior fb) { flyBehavior = fb; }
    void setQuackBehavior(QuackBehavior qb) { quackBehavior = qb; }

    abstract void display();
}

// Concrete Ducks
class MallardDuck extends Duck {
    MallardDuck() { flyBehavior = new FlyWithWings(); quackBehavior = new Quack(); }
    void display() { System.out.println("I am a Mallard Duck!"); }
}

class ModelDuck extends Duck {
    ModelDuck() { flyBehavior = new FlyNoWay(); quackBehavior = new MuteQuack(); }
    void display() { System.out.println("I am a Model Duck!"); }
}

// Client
public class DuckStrategyDemo {
    public static void main(String[] args) {
        Duck duck = new MallardDuck();
        duck.display();
        duck.performFly();
        duck.performQuack();

        System.out.println("\nChanging MallardDuck behaviors...");
        duck.setFlyBehavior(new FlyNoWay());
        duck.setQuackBehavior(new MuteQuack());
        duck.performFly();
        duck.performQuack();

        System.out.println("\nNow testing ModelDuck...");
        Duck model = new ModelDuck();
        model.display();
        model.performFly();
        model.performQuack();

        System.out.println("\nUpgrading ModelDuck with wings and quack...");
        model.setFlyBehavior(new FlyWithWings());
        model.setQuackBehavior(new Quack());
        model.performFly();
        model.performQuack();
    }
}
/* Output:
I am a Mallard Duck!
Flying with wings!
Quack! Quack!

Changing MallardDuck behaviors...
I can't fly.
... (Silence)

Now testing ModelDuck...
I am a Model Duck!
I can't fly.
... (Silence)

Upgrading ModelDuck with wings and quack...
Flying with wings!
Quack! Quack!

 Explanation: Strategy pattern

**ðŸ”¹ Pattern Type:**
Behavioral Design Pattern

**ðŸ”¹ Definition:**
Defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime.

**ðŸ”¹ Why to Use:**
Used when you want to choose an algorithmâ€™s behavior dynamically without changing the class that uses it.

**ðŸ”¹ Real-life Example:**
Like Google Maps â€” you can choose different routes: driving, walking, or cycling â€” the strategy (route algorithm) changes, but the app remains the same.

**ðŸ”¹ Advantages:**

* Promotes flexibility by allowing runtime behavior changes.
* Removes complex conditional (`if-else`) logic.

**ðŸ”¹ Disadvantages:**

* Increases the number of classes/objects.
* Client must understand the differences between strategies.
*/
